[{"categories":["建站"],"content":"想在网上写点东西。相关的平台里微信公众号和知乎不支持markdown，写作体验一般；csdn商业化太严重；之前在cnblogs上发，但今年3月份cnblogs被要求全面整改，据说是因为被恶意发布违规信息和恶意投诉。加上这些平台都需要审核，没有自建博客自由，就考虑自己搭个博客。 博客框架 市面上的开源博客框架大致分为两类。一类是动态博客，如wordpress、typecho、halo等；一类是静态博客，如hexo、Jekyll、hugo等。 动态博客 wordpress和typecho基于php，halo基于Java（springboot+freemarker）。构建这类博客需要买一个服务器和一个域名，在服务器上安装相关语言环境、web server（apache、nginx）和database，安装博客框架并初始化网站配置，最后将域名解析到服务器ip地址上就算完成了。 这类博客一般都有网站后台，可以发布文章和管理站点，功能比较齐全。 静态博客 hexo基于node.js,Jekyll基于ruby,hugo基于go。相比动态博客有以下优点： 免费。直接部署到github page上。理论上也可以部署到服务器上，只需要一个web server。 速度快。不经过php和Java等后台处理，不用数据库。 安全。由于静态网站的简洁，免疫很多web攻击方式。 静态网站的缺点是功能弱，和用户的交互能力不强。适合专注于内容的网站，例如博客。 Hugo hexo和hugo我都试了一下，感觉hugo要更简单，速度更快一些。最后选定了Hugo进行搭建。 首先要安装git和go语言环境，配置环境变量；下载hugo并解压，将可执行文件放在 ‘go安装目录/bin’ 文件夹下,因为已经配了go的环境变量，这样就不用再配置hugo的环境变量。 创建站点 hugo new site 站点名称 如 hugo new site spacelion 创建完会后，在spacelion文件夹会生成以下文件结构： . ├── archetypes # 存放生成博客的模版 ├── content # 存放 markdown 文件 ├── data # 存放 Hugo 处理的数据 ├── layouts # 存放布局文件 ├── resources # 存放一些资源 ├── static # 存放静态文件 图片 CSS JS文件 ├── themes # 存放主题 └── config.toml # 存放 hugo 配置文件 支持 JSON YAML TOML 三种格式配置文件 下载主题 选择一款喜欢的主题下载到themes文件夹下 git clone 主题git地址 目录 如 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 站点配置 配置config.toml，供参考： baseURL = \"https://absolutevalentine.github.io/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"SpaceLion\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [[menu.main]] identifier = \"about\" pre = \"\" post = \"\" name = \"关于\" url = \"/about/\" title = \"\" weight = 4 [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"软件,区块链,机器学习,金融,股票,基金,数字货币,量化投资\" # 网站关键词 keywords = [\"软件\",\"区块链\",\"机器学习\",\"金融\",\"股票\",\"基金\",\"数字货币\",\"量化投资\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"dark\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"/images/app.svg\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"SpaceLion\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\u003ci class='far fa-kiss-wink-heart fa-fw'\u003e\u003c/i\u003e\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = false # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (","date":"2021-06-27","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["建站","Hugo"],"title":"Hugo搭建个人博客","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"关于作者 z世代 热衷于修仙（字面意思） 对能让自己沉浸其中或置身其外的东西感兴趣，比如音乐、拳击、钓鱼等 后端工程师 近期在研究区块链 大佬博客 阮一峰 王垠 友情链接(欢迎留言加友链) 赞助 推荐数字货币支付： BTC : 3DGwJxcersF4QzAWsE1SFpRynSbj2p48Md BCH : bitcoincash:qz4667nsn09j3tucek33fheu8zamlk5lyung2hte6y ETH : 0x69a296adA0f0023Fffe230Cde3733B334dc3dea1 LTC : LY9Wk2yGjthkXsBFGuoWwAc5hyyW13Twrm ATOM : cosmos188fher2rp5avyr3rsc5wcr8dxfdl3vy2t6dney ","date":"2021-06-24","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":["Java"],"content":"为什么使用单元测试 一般来说，验证的两个思路是证明和证伪，分别对应着软件验证的形式化验证和测试。 证明适用于在有明确的逻辑范畴内通过演绎推理（如三段论、假言推理等）进行；证伪可通过举出反例的方式进行。 软件领域的性质导致证明的困难及收效甚微，绝大部分都采用测试来验证。 根据测试目的的不同有功能测试、性能测试等；根据是否了解测试对象分为黑盒测试与白盒测试，单元测试属于白盒测试。 一般来说，开发人员了解代码的结构，自己走一遍流程或CodeReview等形式基本可以发现bug，但为了团队中其他人员及日后的维护，单元测试有一定的存在的合理性。 因此需要保持单元测试中方法的独立性，隔离测试依赖，调用其他方法时需要模拟；给定输入，执行测试，验证输出，需要用到断言。 JAVA常用测试框架junit、mockito、powermock junit常用注解 @Ignore 该注解标记的测试方法在测试中会被忽略 @Test(expected=xxxException.class) 断言该方法会抛出异常 @Test(timeout=1000) 执行时间超过设置的值该案例会失败 @RunWith(JUnit4.class) 默认运行器 @RunWith(PowerMockRunner.class) PowerMockRunner运行器 @RunWith(Parameterized.class) 参数化运行器 @Rule public class ExpectedExceptionsTest { @Rule public ExpectedException thrown = ExpectedException.none(); @Test public void verifiesTypeAndMessage() { thrown.expect(RuntimeException.class); thrown.expectMessage(\"Runtime exception occurred\"); throw new RuntimeException(\"Runtime exception occurred\"); } } 参数化测试 @RunWith(Parameterized.class) public class Testa { @Parameterized.Parameters public static Collection\u003c?\u003e data() { return Arrays.asList(new Object[][] { { \"1+2\", 3 }, { \"1+2+5\", 8 }}); } @InjectMocks Calculator calc; @Parameterized.Parameter(0) public String input; @Parameterized.Parameter(1) public int expected; @Test public void testCalculate() { int r = calc.calculate(this.input); assertEquals(this.expected, r); } } 断言 assertEquals(a, b) 测试a是否等于b（a和b是原始类型数值或者必须为实现比较而具有equal方法） assertFalse(a) 测试a是否为false（假），a是一个Boolean数值。 assertTrue(a) 测试a是否为true（真），a是一个Boolean数值 assertNotNull(a) 测试a是否非空，a是一个对象或者null。 assertNull(a) 测试a是否为null，a是一个对象或者null。 assertNotSame(a, b) 测试a和b是否没有都引用同一个对象。 assertSame(a, b) 测试a和b是否都引用同一个对象。 fail(string) Fail让测试失败，并给出指定信息。 mockito使用介绍 通过代码创建 public class UserServiceTest { private UserService userService; private UserDao mockUserDao; @Before public void setUp() { mockUserDao = mock(UserDao.class); userService = new UserServiceImpl(); userService.setUserDao(mockUserDao); } 通过注解创建 public class UserServiceTest { @InjectMocks private UserServiceImpl userService; @Mock private UserDao mockUserDao; } 常用方法 verify verify(mock, never()).add(); 验证add方法没有被调用 verify(mock, times(2)).add(); 验证add方法被调用了2次 verify(mock, atLeast(n)).someMethod(); 方法至少被调用n次 verify(mock, atMost(n)).someMethod(); 方法最多被调用n次 when when(mock.someMethod()).thenReturn(value1).thenReturn(value2); when(mock.someMethod()).thenThrow(new RuntimeException()); spy List spy = spy(new LinkedList()); when(spy.get(0)).thenReturn(“foo\"); doReturn(\"foo\").when(spy).get(0); 使用powermock 测试private方法 @RunWith(PowerMockRunner.class) //类上加注解 @PrepareForTest({xxx.class}) @PrepareForTest({RpaRightsConfService.class}) public class RpaRightsConfServiceTest { @InjectMocks private RpaRightsConfService rpaRightsConfService; @Test public void getCellValue() throws Exception{ Row row = Mockito.mock(Row.class); Cell cell = Mockito.mock(Cell.class); cell.setCellType(Cell.CELL_TYPE_STRING); Mockito.when(row.getCell(Mockito.anyInt())).thenReturn(cell); //通过反射 Method method1 = rpaRightsConfService.getClass().getDeclaredMethod(\"getCellValue\", Row.class,int.class); method1.setAccessible(true);// 抑制访问修饰符，使得私有方法变为可以访问的 method1.invoke(rpaRightsConfService,row,3); Mockito.verify(row, Mockito.times(1)).getCell(Mockito.anyInt()); //或者通过PowerMockito.method Method method2 = PowerMockito.method(RpaRightsConfService.class, \"getCellValue\", Row.class,int.class); Object x2 = method2.invoke(rpaRightsConfService,row,3); assertEquals(Integer.parseInt(x2.toString()),0); } } 使用powermock mock静态方法/final方法/new @RunWith(PowerMockRunner.class) //类上加注解 @PrepareForTest({xxx.class}) @PrepareForTest({JSON.class,HSSFWorkbook.class}) public class RpaRightsConfServiceTest { @InjectMocks private RpaRightsConfService rpaRightsConfService; @Test public void save() { //mock 静态 PowerMockito.mockStatic(JSON.class); List\u003cRpaRightsConfVo\u003e rpaRightsConfVoList =new ArrayList\u003cRpaRightsConfVo\u003e(); rpaRightsConfVoList.add(new RpaRightsConfVo()); PowerMockito.when(JSON.parseArray(formListJson, RpaRightsConfVo.class)).thenReturn(rpa","date":"2021-06-24","objectID":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/:0:0","tags":["Java","测试"],"title":"关于软件验证中的单元测试","uri":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]